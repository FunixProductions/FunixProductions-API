package com.funixproductions.api.service.twitch.eventsub.services;

import com.funixproductions.api.service.twitch.eventsub.services.handler.TwitchEventSubHandlerService;
import com.funixproductions.core.exceptions.ApiBadRequestException;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.JsonPrimitive;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

/**
 * Service used for handling the public callback route for twitch
 */
@Service
@RequiredArgsConstructor
public class TwitchEventSubCallbackService {

    public static final String TWITCH_MESSAGE_ID = "Twitch-Eventsub-Message-Id";
    public static final String TWITCH_MESSAGE_TYPE = "Twitch-Eventsub-Message-Type";

    public static final String MESSAGE_TYPE_NOTIFICATION = "notification";
    public static final String MESSAGE_TYPE_VERIFICATION = "webhook_callback_verification";
    public static final String MESSAGE_TYPE_REVOCATION = "revocation";

    private static final String BODY_JSON_NOT_VALID = "Le body ne vient pas de twitch (malformé).";

    private final TwitchEventSubHmacService hmacService;
    private final TwitchEventSubHandlerService twitchEventSubHandlerService;

    private final Map<String, Instant> messagesIdsReceived = new HashMap<>();

    /**
     * Method called every time Twitch sends a call
     * @param httpServletRequest servlet request generated by spring
     * @param body the body of the twitch message
     * @throws ApiBadRequestException error
     */
    public String handleNewWebhook(final HttpServletRequest httpServletRequest, final byte[] body) throws ApiBadRequestException {
        final String messageId = httpServletRequest.getHeader(TWITCH_MESSAGE_ID);
        final String messageType = httpServletRequest.getHeader(TWITCH_MESSAGE_TYPE);
        if (messageId == null) {
            throw new ApiBadRequestException("Il manque le message id");
        }
        if (messageType == null) {
            throw new ApiBadRequestException("Il manque le message type");
        }

        if (this.messagesIdsReceived.containsKey(messageId)) {
            throw new ApiBadRequestException("Cette notification à déjà été traitée.");
        } else {
            hmacService.validEventMessage(httpServletRequest, body);
            this.messagesIdsReceived.put(messageId, Instant.now());

            final String bodyParsed = new String(body, StandardCharsets.UTF_8);

            switch (messageType) {
                case MESSAGE_TYPE_NOTIFICATION: {
                    final JsonObject message = getTwitchMessage(bodyParsed);
                    final JsonElement eventElement = message.get("event");

                    if (eventElement.isJsonObject()) {
                        final String notificationType = getNotificationType(message);
                        final JsonObject event = eventElement.getAsJsonObject();

                        twitchEventSubHandlerService.receiveNewNotification(notificationType, event);
                    } else {
                        throw new ApiBadRequestException(BODY_JSON_NOT_VALID);
                    }

                    return "s";
                }
                case MESSAGE_TYPE_VERIFICATION: {
                    final JsonObject message = getTwitchMessage(bodyParsed);
                    return getChallenge(message);
                }
                case MESSAGE_TYPE_REVOCATION:
                    return "s";
                default:
                    throw new ApiBadRequestException("Le message type n'existe pas.");
            }
        }
    }

    /**
     * Method used to clean the messages ids received
     */
    @Scheduled(fixedRate = 10, timeUnit = TimeUnit.MINUTES)
    public void cleanMessagesIds() {
        final Instant now = Instant.now();
        final Map<String, Instant> copyMap = new HashMap<>(this.messagesIdsReceived);

        for (final Map.Entry<String, Instant> entry : copyMap.entrySet()) {
            final Instant receivedAt = entry.getValue();

            if (now.minus(30, ChronoUnit.MINUTES).isAfter(receivedAt)) {
                this.messagesIdsReceived.remove(entry.getKey());
            }
        }
    }

    private JsonObject getTwitchMessage(final String object) {
        final JsonElement element = JsonParser.parseString(object);

        if (element.isJsonObject()) {
            return element.getAsJsonObject();
        } else {
            throw new ApiBadRequestException(BODY_JSON_NOT_VALID);
        }
    }

    private String getNotificationType(final JsonObject message) {
        final JsonElement subElement = message.get("subscription");

        if (subElement.isJsonObject()) {
            final JsonObject subscription = subElement.getAsJsonObject();
            final JsonElement subType = subscription.get("type");

            if (subType.isJsonPrimitive()) {
                final JsonPrimitive subTypeStr = subType.getAsJsonPrimitive();
                return subTypeStr.getAsString();
            } else {
                throw new ApiBadRequestException(BODY_JSON_NOT_VALID);
            }
        } else {
            throw new ApiBadRequestException(BODY_JSON_NOT_VALID);
        }
    }

    private String getChallenge(final JsonObject message) {
        final JsonElement challengeElement = message.get("challenge");

        if (challengeElement.isJsonPrimitive()) {
            final JsonPrimitive challenge = challengeElement.getAsJsonPrimitive();
            return challenge.getAsString();
        } else {
            throw new ApiBadRequestException(BODY_JSON_NOT_VALID);
        }
    }

}
